const crypto = require("crypto");
const Invitation = require("../models/Invitation");
const Workspace = require("../models/Workspace");
const WorkspaceActivity = require("../models/WorkspaceActivity");
const User = require("../models/User");
const AppError = require("../utils/AppError");
const logger = require("../utils/logger");
const mailService = require("./mailService");
const notificationService = require("./notificationService");

interface SendInviteData {
  email: string;
  workspaceId: string;
  role: "admin" | "member";
  invitedBy: string;
}

class InvitationService {
  /**
   * Send invitation to join workspace
   */
  async sendInvite(data: SendInviteData) {
    const { email, workspaceId, role, invitedBy } = data;

    // Verify workspace exists and is not deleted
    const workspace = await Workspace.findOne({
      _id: workspaceId,
      isDeleted: false
    });

    if (!workspace) {
      throw new AppError("Workspace not found", 404);
    }

    // Check if user is already a member
    const existingMember = workspace.members.find(
      (member: any) => member.user && member.user.toString() === invitedBy
    );

    if (!existingMember) {
      throw new AppError("You are not a member of this workspace", 403);
    }

    // Check if email is already a member (by finding user with this email)
    const existingUser = await User.findOne({ email: email.toLowerCase() });
    if (existingUser) {
      const isAlreadyMember = workspace.members.some(
        (member: any) => member.user.toString() === existingUser._id.toString()
      );

      if (isAlreadyMember) {
        throw new AppError("User is already a member of this workspace", 400);
      }
    }

    // Check for existing pending invitation
    const existingInvite = await Invitation.findOne({
      email: email.toLowerCase(),
      workspaceId,
      status: "pending",
      expiresAt: { $gt: new Date() }
    });

    if (existingInvite) {
      throw new AppError("An active invitation already exists for this email", 400);
    }

    // Generate secure token
    const token = crypto.randomBytes(32).toString("hex");

    // Set expiry to 7 days from now
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 7);

    // Create invitation
    const invitation = await Invitation.create({
      email: email.toLowerCase(),
      workspaceId,
      role,
      invitedBy,
      token,
      expiresAt
    });

    // Log activity
    await logger.logActivity({
      userId: invitedBy,
      workspaceId,
      action: "CREATE",
      resourceType: "Workspace",
      resourceId: workspaceId,
      metadata: {
        invitedEmail: email,
        role,
        invitationId: invitation._id
      }
    });

    // Populate invitation details for response
    await invitation.populate("invitedBy", "name email");
    await invitation.populate("workspaceId", "name");

    // Create notification for invited user (if they have an account)
    try {
      const existingUser = await User.findOne({ email: email.toLowerCase() });
      if (existingUser) {
        const inviter = await User.findById(invitedBy);
        const frontendUrl = process.env.FRONTEND_URL || "http://localhost:3000";
        
        await notificationService.createNotification({
          recipientId: existingUser._id.toString(),
          type: "INVITATION",
          title: "Workspace Invitation",
          body: `${inviter?.name || 'Someone'} invited you to join ${workspace.name}`,
          data: {
            workspaceId,
            token,
            inviteUrl: `${frontendUrl}/join?token=${token}`,
            workspaceName: workspace.name,
            inviterName: inviter?.name,
          },
        });
      }
    } catch (error) {
      console.error("Failed to create invitation notification:", error);
    }

    // Send invitation email (non-blocking)
    // If email fails, we log it but don't throw an error
    try {
      const inviter = await User.findById(invitedBy);
      if (inviter) {
        await mailService.sendInvitationEmail({
          toEmail: email,
          workspaceName: workspace.name,
          inviterName: inviter.name,
          inviteToken: token
        });
      }
    } catch (emailError) {
      // Log the error but don't fail the invitation creation
      console.error("Failed to send invitation email:", emailError);
      // You could also log this to your logging service
      // logger.error("Email sending failed", { error: emailError, invitationId: invitation._id });
    }

    return invitation;
  }

  /**
   * Accept invitation and join workspace
   */
  async acceptInvite(token: string, userId: string) {
    // Find pending invitation by token
    const invitation = await Invitation.findOne({
      token,
      status: "pending"
    })
      .populate("workspaceId", "name members")
      .populate("invitedBy", "name email");

    if (!invitation) {
      throw new AppError("Invalid or expired invitation", 404);
    }

    // Validate expiry
    if (new Date() > invitation.expiresAt) {
      invitation.status = "expired";
      await invitation.save();
      throw new AppError("This invitation has expired", 400);
    }

    // Get user details
    const user = await User.findById(userId);
    if (!user) {
      throw new AppError("User not found", 404);
    }

    // Verify email matches (case-insensitive)
    if (user.email.toLowerCase() !== invitation.email.toLowerCase()) {
      throw new AppError(
        "This invitation was sent to a different email address",
        403
      );
    }

    // Get workspace
    const workspace = await Workspace.findOne({
      _id: invitation.workspaceId,
      isDeleted: false
    });

    if (!workspace) {
      throw new AppError("Workspace not found or has been deleted", 404);
    }

    // Check if user is already a member
    const isAlreadyMember = workspace.members.some(
      (member: any) => member.user.toString() === userId
    );

    if (isAlreadyMember) {
      // User is already a member - return workspace info instead of error
      const existingWorkspace = await Workspace.findById(workspace._id)
        .populate("owner", "name email")
        .populate("members.user", "name email");

      const userMember = workspace.members.find(
        (member: any) => member.user.toString() === userId
      );

      return {
        workspace: existingWorkspace,
        role: userMember.role,
        alreadyMember: true
      };
    }

    // Add user to workspace members using $push
    await Workspace.findByIdAndUpdate(
      workspace._id,
      {
        $push: {
          members: {
            user: userId,
            role: invitation.role
          }
        }
      },
      { returnDocument: "after" }
    );

    // Mark invitation as accepted
    invitation.status = "accepted";
    await invitation.save();

    // Log activity
    await logger.logActivity({
      userId,
      workspaceId: workspace._id.toString(),
      action: "UPDATE",
      resourceType: "Workspace",
      resourceId: workspace._id.toString(),
      metadata: {
        action: "member_joined",
        role: invitation.role,
        invitationId: invitation._id
      }
    });

    // Create workspace activity
    await WorkspaceActivity.createActivity({
      workspace: workspace._id.toString(),
      user: userId,
      type: "member_joined",
      description: `joined the workspace`,
      targetUser: userId,
      metadata: { role: invitation.role }
    });

    // Send push notification to workspace owner (non-blocking)
    try {
      notificationService.createNotification({
        recipientId: workspace.owner.toString(),
        type: "INVITE_ACCEPTED",
        title: "Invitation Accepted",
        body: `${user.name} joined ${workspace.name}`,
        data: {
          resourceId: workspace._id.toString(),
          resourceType: "Workspace",
          workspaceId: workspace._id.toString(),
        },
      }).catch((error: any) => {
        console.error("Failed to send invitation accepted notification:", error);
      });
    } catch (error) {
      console.error("Failed to send invitation accepted notification:", error);
    }

    // Return workspace details
    const updatedWorkspace = await Workspace.findById(workspace._id)
      .populate("owner", "name email")
      .populate("members.user", "name email");

    return {
      workspace: updatedWorkspace,
      role: invitation.role
    };
  }

  /**
   * Get all pending invitations for a workspace
   */
  async getWorkspaceInvitations(workspaceId: string) {
    const invitations = await Invitation.find({
      workspaceId,
      status: "pending",
      expiresAt: { $gt: new Date() }
    })
      .populate("invitedBy", "name email")
      .sort("-createdAt");

    return invitations;
  }

  /**
   * Cancel/revoke an invitation
   */
  async cancelInvitation(invitationId: string, userId: string, workspaceId: string) {
    const invitation = await Invitation.findOne({
      _id: invitationId,
      workspaceId,
      status: "pending"
    });

    if (!invitation) {
      throw new AppError("Invitation not found", 404);
    }

    // Mark as expired instead of deleting (for audit trail)
    invitation.status = "expired";
    await invitation.save();

    // Log activity
    await logger.logActivity({
      userId,
      workspaceId,
      action: "DELETE",
      resourceType: "Workspace",
      resourceId: workspaceId,
      metadata: {
        action: "invitation_cancelled",
        invitationId: invitation._id,
        email: invitation.email
      }
    });

    return { message: "Invitation cancelled successfully" };
  }

  /**
   * Get user's pending invitations
   */
  async getUserInvitations(userEmail: string) {
    const invitations = await Invitation.find({
      email: userEmail.toLowerCase(),
      status: "pending",
      expiresAt: { $gt: new Date() }
    })
      .populate("workspaceId", "name")
      .populate("invitedBy", "name email")
      .sort("-createdAt");

    return invitations;
  }

  /**
   * Verify invitation token (public endpoint)
   */
  async verifyInvitation(token: string) {
    // Find invitation by token
    const invitation = await Invitation.findOne({
      token,
      status: "pending"
    })
      .populate("workspaceId", "name")
      .populate("invitedBy", "name email");

    if (!invitation) {
      throw new AppError("Invitation invalid or expired", 400);
    }

    // Check if expired
    if (new Date() > invitation.expiresAt) {
      throw new AppError("Invitation invalid or expired", 400);
    }

    // Return invitation details
    return {
      workspaceName: (invitation.workspaceId as any).name,
      inviterName: (invitation.invitedBy as any).name,
      email: invitation.email,
      role: invitation.role
    };
  }
}

module.exports = new InvitationService();

export {};
